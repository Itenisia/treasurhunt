{% extends 'base.html' %}
{% load static %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <h1 class="text-4xl font-bold text-center mb-4 text-red-600">Champ de Bataille</h1>

    <div class="text-center mb-4">
        <h2 class="text-2xl text-white">
            <span class="text-blue-400">{{ battle.attacker.username }}</span>
            vs
            <span class="text-red-400">{{ battle.defender.username|default:"Défenseur" }}</span>
        </h2>
        <div id="battle-status" class="text-xl font-bold mt-2 text-yellow-400">Combat en cours...</div>
    </div>

    <div class="flex justify-center">
        <canvas id="battleCanvas" width="600" height="600"
            class="bg-gray-900 border-4 border-gray-700 rounded shadow-2xl"></canvas>
    </div>

    <div class="text-center mt-6">
        <a href="{% url 'siege:hq' %}" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">
            Retour au QG
        </a>
    </div>
</div>

<script>
    const canvas = document.getElementById('battleCanvas');
    const ctx = canvas.getContext('2d');
    const CELL_SIZE = 60;
    const GRID_SIZE = 10;

    const attackerLayout = {{ battle.attacker_layout| safe }}; // {"x,y": "slug"}
    const defenderLayout = {{ battle.defender_layout| safe }};

    const unitsConfig = {
        {% for slug, unit in units_config.items %}
    "{{ slug }}": {
        "emoji": "{{ unit.emoji }}",
            "name": "{{ unit.name }}",
                "power": { { unit.power } },
        "hp": { { unit.power } } * 10, // Simple HP formula
            "range": 1, // Melee default
                "speed": 1
    },
    {% endfor %}
    };

    // Initialize Units
    let units = [];

    function initUnits(layout, owner) {
        for (const [pos, slug] of Object.entries(layout)) {
            const [x, y] = pos.split(',').map(Number);
            const config = unitsConfig[slug];
            units.push({
                id: Math.random().toString(36).substr(2, 9),
                x: x,
                y: y,
                type: slug,
                owner: owner, // 'attacker' or 'defender'
                emoji: config.emoji,
                hp: config.hp,
                maxHp: config.hp,
                power: config.power,
                range: config.range,
                lastAction: 0
            });
        }
    }

    initUnits(attackerLayout, 'attacker');
    initUnits(defenderLayout, 'defender');

    let battleOver = false;

    function draw() {
        // Clear
        ctx.fillStyle = '#1a202c';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Grid
        ctx.strokeStyle = '#2d3748';
        for (let i = 0; i <= GRID_SIZE; i++) {
            ctx.beginPath();
            ctx.moveTo(i * CELL_SIZE, 0);
            ctx.lineTo(i * CELL_SIZE, canvas.height);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, i * CELL_SIZE);
            ctx.lineTo(canvas.width, i * CELL_SIZE);
            ctx.stroke();
        }

        // Zones
        ctx.fillStyle = 'rgba(66, 153, 225, 0.1)'; // Blue tint for attacker
        ctx.fillRect(0, 0, 3 * CELL_SIZE, canvas.height);

        ctx.fillStyle = 'rgba(245, 101, 101, 0.1)'; // Red tint for defender
        ctx.fillRect(7 * CELL_SIZE, 0, 3 * CELL_SIZE, canvas.height);

        // Units
        units.forEach(u => {
            const px = u.x * CELL_SIZE + CELL_SIZE / 2;
            const py = u.y * CELL_SIZE + CELL_SIZE / 2;

            // HP Bar
            const hpPct = u.hp / u.maxHp;
            ctx.fillStyle = 'red';
            ctx.fillRect(px - 20, py - 25, 40, 5);
            ctx.fillStyle = '#48bb78';
            ctx.fillRect(px - 20, py - 25, 40 * hpPct, 5);

            // Emoji
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(u.emoji, px, py);

            // Owner Indicator
            ctx.beginPath();
            ctx.arc(px + 15, py + 15, 5, 0, 2 * Math.PI);
            ctx.fillStyle = u.owner === 'attacker' ? '#4299e1' : '#f56565';
            ctx.fill();
        });
    }

    function getDistance(u1, u2) {
        return Math.abs(u1.x - u2.x) + Math.abs(u1.y - u2.y); // Manhattan distance
    }

    function update() {
        if (battleOver) return;

        const attackers = units.filter(u => u.owner === 'attacker');
        const defenders = units.filter(u => u.owner === 'defender');

        if (attackers.length === 0) {
            endBattle('defender');
            return;
        }
        if (defenders.length === 0) {
            endBattle('attacker');
            return;
        }

        // Simple Turn Logic (random order for chaos/fairness)
        // In a real game, we'd use initiative.
        // Here we just iterate all units and let them act if cooldown ready.
        // For simplicity, let's move everyone once per "tick" (approx 1 sec)

        units.forEach(u => {
            if (u.hp <= 0) return;

            // Find nearest enemy
            let enemies = u.owner === 'attacker' ? defenders : attackers;
            enemies = enemies.filter(e => e.hp > 0);

            if (enemies.length === 0) return;

            let target = enemies.reduce((prev, curr) => {
                return getDistance(u, curr) < getDistance(u, prev) ? curr : prev;
            });

            const dist = getDistance(u, target);

            if (dist <= u.range) {
                // Attack
                target.hp -= u.power;
                // Visual effect?
            } else {
                // Move towards target
                // Simple pathfinding: move closer in X or Y
                let dx = target.x - u.x;
                let dy = target.y - u.y;

                let newX = u.x;
                let newY = u.y;

                if (Math.abs(dx) > Math.abs(dy)) {
                    newX += Math.sign(dx);
                } else {
                    newY += Math.sign(dy);
                }

                // Check collision
                if (!units.some(other => other.x === newX && other.y === newY && other.hp > 0)) {
                    u.x = newX;
                    u.y = newY;
                }
            }
        });

        // Cleanup dead
        units = units.filter(u => u.hp > 0);
    }

    function endBattle(winner) {
        battleOver = true;
        const statusEl = document.getElementById('battle-status');
        const winnerName = winner === 'attacker' ? '{{ battle.attacker.username }}' : '{{ battle.defender.username|default:"Défenseur" }}';
        statusEl.textContent = `Victoire de ${winnerName} !`;
        statusEl.classList.add(winner === 'attacker' ? 'text-blue-500' : 'text-red-500');

        // Send result to server (Optional, if we trust client)
        // For now, server uses Power calculation, so this is just visual.
        // But user wanted simulation to matter.
        // Let's just show the result. The server "Battle State" API could be polled to see official result.
    }

    // Game Loop
    setInterval(() => {
        update();
        draw();
    }, 1000); // 1 tick per second

    draw();

</script>
{% endblock %}